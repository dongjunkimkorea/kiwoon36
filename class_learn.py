# -*- coding: utf-8 -*-
"""
Created on Mon Jan 28 20:26:51 2019

@author: DongJun Kim
"""

print("모듈이 실행 되기 전에 실행 돼네. 인식하고 있자.")


"""
상속
상속이란 기존의 클래스에 대한 설계도를 이어받아 그 일부를 수정하여 새로운 클래스를
만드는 매커니즘이다.
"""
class MyClass(object):
    
    x = 0 """인스턴스변수로 사용 될 수 도 있고, 클래스 변수로도 사용 될 수 있다. self.x , MyClass.x"""
    y = 0

    def __init__(self):
        
        """
        코드상에서 self를 붙였기 때문에 인스턴스 변수로 사용된다.
        즉, 인스턴스 네임스페이스에 변수가 생성된다.
        """    
        self.a = 'aa'
        self.b = 'bb'
            
    def my_print(self):
        """
        모듈(class_learn.py)이 python class_learn.py 로 콘솔에서 실행 돼면, 즉 어는 방법을 통해서든
        실행이 되면 메모리에 class 가 로딩되면서 namespace가 생성된다.
        
        그리고 나서 코드 주에서 인스턴스(변수)를 만드는 코드가 있다며
        인스턴스에 해당하는 객체가 메모리에 만들어 지면서 인스턴스namespace가 메모리에 생성돤다.
        
        속성(변수_데이터)을 참조(수정/변경)하는 문법에 따라, 즉 아래와 같은 코드.
        self.x = 데이터
        MyClass.x = 데이터
        에서는 생성된 네임스페이스 공간(인스턴스/클래스)에 데이터를 저장하고.
        
        속성(변수_테이터)을 참조(조회)하는 문법에 따라, 즉 아래와 같은 코드.
        self.x
        MyClass.x
        에서는 두가지로 생각 해야 하는데
        그 하나는 인스턴스에서 접근 할때, 해당하는 x값이 인스턴스 네임스페이스에서 먼저 뒤진후,
        없으면 클래스 네임스페이스에서 그 변수(x)의 값을 참조한다.
        
        그 두번째는 클래스명으로 접근 할때, 그때는 그냥 클래스 네임스페이스에서 그값을 참조한다.
        
        """
        self.x += 1
        MyClass.y += 1
        
        '''
        self.y는 인스턴스에 y의 값이 없기 때문에, 클래스네임스페이스에서 해당 값을 참조한다.
        그렇기 때문에 self.y의 값은 "1"이다.
        '''
        print("(x,y) = ( {} , {} )".format(self.x, self.y))

print("class 선언 뒤에 코드가 실행 되네. 인식하고 있자.")

if __name__ =="__main__":
    print("class_learn.py 를 바로 실행 했기 때문에, if 문으로 들어와서 실행됐다. 인식하자.")
    
    f = MyClass
    
    a = MyClass()
    
    a.my_print()